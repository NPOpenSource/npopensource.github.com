<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[温杰的博客]]></title>
  <link href="http://npopensource.github.io/atom.xml" rel="self"/>
  <link href="http://npopensource.github.io/"/>
  <updated>2015-08-06T14:20:43+08:00</updated>
  <id>http://npopensource.github.io/</id>
  <author>
    <name><![CDATA[温杰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[记录unix命令的使用]]></title>
    <link href="http://npopensource.github.io/blog/2015/08/04/ji-lu-unixming-ling-de-shi-yong/"/>
    <updated>2015-08-04T18:07:24+08:00</updated>
    <id>http://npopensource.github.io/blog/2015/08/04/ji-lu-unixming-ling-de-shi-yong</id>
    <content type="html"><![CDATA[<p>经常为在mac 终端操作，所以不得不学习一些终端命令并做下记录，方便以后查询。</p>

<h2>命令查询</h2>

<p>其实所有的命令参数都是可以通过man 来查询的。</p>

<pre><code>eg：
man cd
man rm
man ls
man open
</code></pre>

<p>都有命令的详细使用情况</p>

<h2>命令介绍</h2>

<ul>
<li>rm -rf xxx 删除文件夹xxx（包括里面的内容）</li>
<li>mkdir xxx 新建xxx文件夹</li>
<li>cd xxx 进入xxx文件夹，xxx可以是个路径</li>
<li>open . 使用Finder打开当前目录</li>
<li>open ./source 使用Finder打开当前目录下的source文件夹</li>
<li>ls 查看当面文件夹中的目录列表</li>
<li>cd .. 返回上已目录</li>
<li>rm xxx 删除文件</li>
<li>vi xxx 打开文件
  进入vi文件之后，q键是功能切换
                a键是插入操作
                shift+q 进入退出模式。wq 写入并保存 q! 强制退出不保存</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GitPages + Octopress搭建博客（转）]]></title>
    <link href="http://npopensource.github.io/blog/2015/08/04/gitpages-plus-octopressda-jian-bo-ke-(zhuan-)/"/>
    <updated>2015-08-04T16:39:04+08:00</updated>
    <id>http://npopensource.github.io/blog/2015/08/04/gitpages-plus-octopressda-jian-bo-ke-(zhuan-)</id>
    <content type="html"><![CDATA[<h1>直接转兄弟的链接</h1>

<p><a href="http://summerhanada.github.io/blog/2015/07/07/da-jian-zi-ji-de-bo-ke/">GitPages + Octopress 搭建博客</a></p>

<h2>我在创建中遇到的问题</h2>

<p>主要问题是输入命令rake deploy 的时候报下面的错误</p>

<pre><code>## Pushing generated _deploy website
To git@github.com:NPOpenSource/npopensource.github.com.git
! [rejected]        master -&gt; master (non-fast-forward)
error: failed to push some refs to 'git@github.com:NPOpenSource/    npopensource.github.com.git'
hint: Updates were rejected because the tip of your current branch is   behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
</code></pre>

<p>这个原因的产生是因为在目录 /octopress/_deploy/ 下面的文件和远程有冲突导致的。</p>

<p>解决办法是 在 /octopress  输入命令git pull origin master</p>

<p> cd _deploy/
进入该文件夹 git remote -v<br/>
查看当前文件下 有冲突的文件  将有冲突的文件解决掉就行了 并提交</p>

<p>保证 git status 结果为</p>

<pre><code> On branch master
nothing to commit, working directory clean
</code></pre>

<p>之后cd .. 退出到 /octopress</p>

<p>查看 git remote -v  将修改的文件也提交
 保证 git status  结果为</p>

<pre><code>On branch master
nothing to commit, working directory clean
</code></pre>

<p>最后再次运行 rake deploy 就行了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git的学习使用]]></title>
    <link href="http://npopensource.github.io/blog/2015/08/04/gitde-xue-xi-shi-yong/"/>
    <updated>2015-08-04T16:33:09+08:00</updated>
    <id>http://npopensource.github.io/blog/2015/08/04/gitde-xue-xi-shi-yong</id>
    <content type="html"><![CDATA[<blockquote><p>用github 不得不学习下 git 命令行。 要想学好git ，我认为，首先要弄懂git 原理，接着熟练掌握git 命令行。</p></blockquote>

<h2>git原理</h2>

<h3>原理图</h3>

<p><img src="http://npopensource.github.io/images/git-yuanli.png" alt="alt text" />
这张图能比较直观的看出git 的工作原理和简单关键命令。</p>

<h3>git 目录</h3>

<p><img src="http://npopensource.github.io/images/git-mulu.png" alt="alt text" /></p>

<h3>关于版本控制（可以不看，讲述git的由来）</h3>

<blockquote><p>本地版本控制系统</p></blockquote>

<pre><code>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单。不过坏处也不少：有时候会混淆所在的工作目录，一旦弄错文件丢了数据就没法撤销恢复。

为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。
</code></pre>

<p><img src="http://npopensource.github.io/images/git-local.png" title="本地版本控制" alt="alt text" /></p>

<pre><code>其中最流行的一种叫做 rcs，现今许多计算机系统上都还看得到它的踪影。甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。它的工作原理基本上就是保存并管理文件补丁（patch）。文件补丁是一种特定格式的文本文件，记录着对应文件修订前后的内容变化。所以，根据每次 修订后的补丁，rcs 可以通过不断打补丁，计算出各个版本的文件内容。
</code></pre>

<blockquote><p>集中化的版本控制系统</p></blockquote>

<pre><code>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统（ Centralized Version Control Systems，简称 CVCS ）应运而生。这类系统，诸如 CVS，Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这 已成为版本控制系统的标准做法
</code></pre>

<p><img src="http://npopensource.github.io/iamges/git-morepeople.png" alt="alt text" /></p>

<pre><code>这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。

事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要 是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就还是会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，而被客户端 提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完整提取出来过。本地版本控制系统也存在类似问题，只要整个项 目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险
</code></pre>

<blockquote><p>分布式版本控制系统</p></blockquote>

<pre><code>于是分布式版本控制系统（ Distributed Version Control System，简称 DVCS ）面世了。在这类系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜 像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。
</code></pre>

<p><img src="http://npopensource.github.io/images/git-fenbushi.png" alt="alt text" /></p>

<pre><code>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。
</code></pre>

<h3>git基础</h3>

<blockquote><p>直接记录快照，而非差异比较</p></blockquote>

<pre><code>Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统 （CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容
</code></pre>

<p><img src="http://npopensource.github.io/images/git-otherSys.png" alt="alt text" /></p>

<pre><code>Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照 的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。
</code></pre>

<p><img src="http://npopensource.github.io/images/git-differentSys.png" alt="alt text" /></p>

<pre><code>这是 Git 同其他系统的重要区别。它完全颠覆了传统版本控制的套路，并对各个环节的实现方式作了新的设计。Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的 VCS
</code></pre>

<blockquote><p>近乎所有操作都是本地执行</p></blockquote>

<pre><code>在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVCS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。
举个例子，如果要浏览项目的历史更新摘要，Git 不用跑到外面的服务器上去取数据回来，而直接从本地数据库读取后展示给你看。所以任何时候你都可以马上翻阅，无需等待。如果想要看当前版本的文件和一个月 前的版本之间有何差异，Git 会取出一个月前的快照和当前文件作一次差异运算，而不用请求远程服务器来做这件事，或是把老版本的文件拉到本地来作比较。
</code></pre>

<blockquote><p>时刻保持数据完整性</p></blockquote>

<pre><code>在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。

Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是：

24b9da6552252987aa493b52f8696cd6d3b00373

Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。
</code></pre>

<blockquote><p>多数操作仅添加数据</p></blockquote>

<pre><code>常用的 Git 操作大多仅仅是把数据添加到数据库。因为任何一种不可逆的操作，比如删除数据，都会使回退或重现历史版本变得困难重重。在别的 VCS 中，若还未提交更新，就有可能丢失或者混淆一些修改的内容，但在 Git 里，一旦提交快照之后就完全不用担心丢失数据，特别是养成定期推送到其他仓库的习惯的话。
</code></pre>

<blockquote><p>文件的三种状态</p></blockquote>

<pre><code>好，现在请注意，接下来要讲的概念非常重要。对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库 中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。

由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。
</code></pre>

<p><img src="http://npopensource.github.io/images/git-option.png" alt="alt text" /></p>

<pre><code>每个项目都有一个 Git 目录（译注：如果 git clone 出来的话，就是其中 .git 的目录；如果git clone --bare 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。

从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。

所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。

基本的 Git 工作流程如下：

1. 在工作目录中修改某些文件。 2. 对修改后的文件进行快照，然后保存到暂存区域。 3. 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。

所以，我们可以从文件所处的位置来判断状态：如果是 Git 目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就 是已修改状态。
</code></pre>

<p>请记住，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记 录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存 区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p>

<p>在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。所以使用 Git 时的文件状态变化周期如图
<img src="http://npopensource.github.io/images/git-change.png" alt="alt text" /></p>

<h3>git命令</h3>

<pre><code>Git 提供了一个叫做 git config 的工具（译注：实际是 git-config 命令，只不过可以通过 git 加一个名字来呼叫此命令。），专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：

/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用--system 选项，读写的就是这个文件。
~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用--global 选项，读写的就是这个文件。
当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以.git/config 里的配置会覆盖/etc/gitconfig 中的同名变量。
</code></pre>

<ul>
<li>git config &ndash;list  要检查已有的配置信息</li>
<li>git config &ndash;global user.name &ldquo;John Doe&rdquo;  配置用户名</li>
<li>git config &ndash;global user.email <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x6a;&#x6f;&#x68;&#x6e;&#100;&#x6f;&#x65;&#x40;&#x65;&#120;&#97;&#x6d;&#112;&#108;&#101;&#46;&#99;&#111;&#x6d;">&#106;&#111;&#104;&#110;&#100;&#x6f;&#x65;&#x40;&#101;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;</a> 配置邮件</li>
<li>git config &ndash;global core.editor emacs   文本编辑器</li>
<li>git config &ndash;global merge.tool vimdiff  配置差异性分析工具（Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。）</li>
<li>git config user.name   查看用户名</li>
<li>git help  config  查看git config的文档</li>
<li>git &ndash;help 查看git使用文档</li>
<li>man git 查看git 文档</li>
<li><p>git help 查看git使用文档</p></li>
<li><p>git init  在工作目录中初始化新仓库（初始化后，在当前目录下会出现一个名为 .git 的目录）</p></li>
<li>git add git add &lt;文件或者文件夹> 可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）潜台词就是把目标文件快照放入暂存区域）</li>
<li>git commit -m &lsquo;initial project version&rsquo; 提交文件</li>
<li>git clone git://github.com/schacon/grit.git 克隆文件到当前文件夹</li>
<li>git clone git://github.com/schacon/grit.git mygrit  克隆文件到当前文件夹并将文件夹命名为 myfrit</li>
<li>git status 检查当前文件状态</li>
<li>cat .gitignore <em>.[oa] </em>~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件   （<strong>可以添加多个忽略文件匹配，之间用空格空开</strong>）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>文件 .gitignore 的格式规范如下：
</span><span class='line'>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。
</span><span class='line'>可以使用标准的 glob 模式匹配。 * 匹配模式最后跟反斜杠（/）说明要忽略的是目录。 *    要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。
</span><span class='line'>
</span><span class='line'>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如[0-9] 表示匹配所有 0 到 9 的数字）。</span></code></pre></td></tr></table></div></figure>


<ul>
<li>git diff  查看尚未暂存的文件更新了哪些部分</li>
<li><p>git diff &ndash;cached 已经暂存起来的文件和上次提交时的快照之间的差异</p>

<p>  例如 vim read
      git add read    ///这第一个新生产的问题提交到git 缓存区域了
      vim read 打开read 输入文字abc
      git add read   ///第二次保存快照
      vim  read  再次打开read  输入文字efg （现在文字问abcdef）</p>

<pre><code>  git diff  这时候输出的结果是
  diff --git a/README b/README
  index 40bae04..f74d0d3 100644
  --- a/README
  +++ b/README
  @@ -1 +1 @@
  -abc
  +abcdef

  比较的是未提交的文件与缓存区的文件比较（个人理解）

  git diff --cached 这时候输出的结果是
  diff --git a/README b/README
  new file mode 100644
  index 0000000..40bae04
  --- /dev/null
  +++ b/README
  @@ -0,0 +1 @@
  +abc

  比较的是缓存区最后两次的比较 （个人理解）
</code></pre></li>
<li><p>git commit 将暂存文件提交</p>

<pre><code> 可以看到，默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。退出编辑器时，Git 会丢掉注释行，将说明内容和本次更新提交到仓库。
</code></pre></li>
<li><p>git commit -m &ldquo;提交说明&rdquo; -m 参数后跟提交说明的方式，在一行命令中提交更新</p></li>
<li>git commit -a  自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</li>
<li>git rm 从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。</li>
<li>git rm -f 删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母），以防误删除文件后丢失修改的内容</li>
<li>git rm &ndash;cached readme.txt  另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆.a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 &ndash;cached 选项即可</li>
<li>git rm log/*.log  后面可以列出文件或者目录的名字，也可以使用 glob 模式</li>
<li><p>git mv file_from file_to 移动文件</p>

<pre><code> 其实，运行 git mv 就相当于运行了下面三条命令：
 $ mv README.txt README $ git rm README.txt $ git add README
</code></pre></li>
<li><pre><code>git log  查看提交历史
</code></pre></li>
<li><pre><code>git log -p -2   -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新
</code></pre></li>
<li><p>git commit &ndash;amend  有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 &ndash;amend 选项重新提交（修改提交信息）</p></li>
<li><p>git reset HEAD benchmarks.rb  取消已经暂存的文件</p></li>
<li><p>git checkout &ndash; benchmarks.rb  取消对文件的修改</p></li>
<li><p>git remote 查看当前的远程库</p></li>
<li>git remote -v 查看当前的远程库,显示对应的克隆地址</li>
</ul>


<blockquote><p>远程操作</p></blockquote>

<ul>
<li>git remote add [shortname] [url]  要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用</li>
</ul>


<h4>参考链接：</h4>

<ul>
<li><a href="http://www.bootcss.com/p/git-guide/">git - 简易指南</a></li>
<li><a href="http://my.oschina.net/sunchp/blog/346076">git - 原理比较清晰</a></li>
</ul>


<h5>延伸连接</h5>

<ul>
<li><a href="http://www.open-open.com/lib/view/open1328069609436.html">git详解之一</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328069733264.html">git详解之二</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rake在octopress中的使用命令介绍]]></title>
    <link href="http://npopensource.github.io/blog/2015/08/04/rakezai-octopresszhong-de-shi-yong-ming-ling-jie-shao/"/>
    <updated>2015-08-04T16:23:23+08:00</updated>
    <id>http://npopensource.github.io/blog/2015/08/04/rakezai-octopresszhong-de-shi-yong-ming-ling-jie-shao</id>
    <content type="html"><![CDATA[<p>刚开始接触octopress ，对rake命令使用的较少，特在此记录，记录每个命令的作用。</p>

<h2>命令</h2>

<ul>
<li>rake generate 将 /octopress/source/_posts 目录下的 .markdown 文件 翻译成html网页</li>
<li>rake preview 生成本地网页服务器，端口号4000   <a href="http://localhost:4000">http://localhost:4000</a></li>
<li>rake deploy  将本地的_deploy 修改的文件提交到 github上面去。</li>
<li>rake new_post[&lsquo;新的博客名字&rsquo;] 在 octopress/source/_posts 目录下创建博客，名字为《新的博客名字》</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Makedown的简单使用]]></title>
    <link href="http://npopensource.github.io/blog/2015/08/03/markdown/"/>
    <updated>2015-08-03T11:52:07+08:00</updated>
    <id>http://npopensource.github.io/blog/2015/08/03/markdown</id>
    <content type="html"><![CDATA[<h2>纪要</h2>

<pre><code> 由于要用markdown写博客并进行排版，所以暂时先简单的学习使用下。
</code></pre>

<h2>编辑软件</h2>

<p>   <a href="http://pan.baidu.com/s/1qW9RRBI">Mou link</a></p>

<pre><code>markdown语言编辑软件.
</code></pre>

<h2>语法纪要</h2>

<h4>段落、标题、区块代码</h4>

<p>一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。</p>

<p>Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。</p>

<p>区块引用则使用 email 形式的 &lsquo;>&rsquo; 角括号</p>

<p>常用语法：
    <table border=4 width=400 align=center bordercolor=red>
    <tr>
        <td>输出后的效果  </td>
        <td>Markdown    </td>
        <td>快捷键   </td>
        <td>是否好用    </td>     <br/>
    </tr>
    <tr>
        <td>H1  </td>
        <td># Heading   </td>
        <td>    </td>
        <td>    </td>
    </tr>
      <tr>
        <td>H2  </td>
        <td>## Heading  </td>
        <td>Ctrl/⌘ + H    </td>
        <td>不好用   </td>
    </tr>
     </tr>
      <tr>
        <td>H3  </td>
        <td>### Heading </td>
        <td>Ctrl/⌘ + H (x2)   </td>
        <td>不好用   </td>
    </tr>
     </tr>
      <tr>
        <td>Blockquote</td>
        <td>> quote</td>
        <td>Ctrl + Q    </td>
        <td>好用  </td>
    </tr>
     </tr>
    </table></p>

<p>Markdown 语法:</p>

<pre><code>A First Level Header
====================
A Second Level Header
---------------------

Now is the time for all good men to come to the aid of their country. This is just a regular paragraph.

The quick brown fox jumped over the lazy dog's back.
### Header 3

&gt; This is a blockquote.
&gt; 
&gt; This is the second paragraph in the blockquote.
&gt;
&gt; ## This is an H2 in a blockquote
</code></pre>

<p>输出 HTML 为：</p>

<pre><code>&lt;h1&gt;A First Level Header&lt;/h1&gt;
&lt;h2&gt;A Second Level Header&lt;/h2&gt;
&lt;p&gt;Now is the time for all good men to come to the aid of their country. This is just a regular paragraph.&lt;/p&gt;
&lt;p&gt;The quick brown fox jumped over the lazy dog's back.&lt;/p&gt;
&lt;h3&gt;Header 3&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a blockquote.&lt;/p&gt;
&lt;p&gt;This is the second paragraph in the blockquote.&lt;/p&gt;
&lt;h2&gt;This is an H2 in a blockquote&lt;/h2&gt;
&lt;/blockquote&gt;
</code></pre>

<p>注释：</p>

<pre><code>如果你在项目之间插入空行，那项目的内容会用 &lt;p&gt; 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。
如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;、&lt; 和 &gt; 也一样会自动转成 HTML 实体
</code></pre>

<h4>修辞和强调</h4>

<p>Markdown 使用星号和底线来标记需要强调的区段。</p>

<p>  常用语法：
    <table border=4 width=400 align=center bordercolor=red>
    <tr>
        <td>输出后的效果  </td>
        <td>Markdown    </td>
        <td>快捷键   </td>
        <td>是否好用    </td>     <br/>
    </tr>
    <tr>
        <td>Bold    </td>
        <td><strong>text</strong>    </td>
        <td>⌘ + B（mac）</td>
        <td>好用  </td>     <br/>
    </tr>
      <tr>
        <td>Emphasize   </td>
        <td><em>text</em>  </td>
        <td>⌘ + I（mac）    </td>
        <td>好用  </td>
    </tr>
     </tr>
      <tr>
        <td>Strike-through  </td>
        <td>#<del>text</del>   </td>
        <td>Ctrl + Alt + U</td>
        <td>不好用</td>
    </tr>
     </tr>
      <tr>
        <td>Blockquote</td>
        <td>> quote</td>
        <td>Ctrl + Q    </td>
    </tr>
     </tr>
    </table></p>

<p>   Markdown 语法:</p>

<pre><code>Some of these words *are emphasized*.
Some of these words _are emphasized also_.
Use two asterisks for **strong emphasis**.
Or, if you prefer, __use two underscores instead__.
</code></pre>

<p>输出 HTML 为:</p>

<pre><code>&lt;p&gt;Some of these words &lt;em&gt;are emphasized&lt;/em&gt;.
Some of these words &lt;em&gt;are emphasized also&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Use two asterisks for &lt;strong&gt;strong emphasis&lt;/strong&gt;.
Or, if you prefer, &lt;strong&gt;use two underscores instead&lt;/strong&gt;.&lt;/p&gt;
</code></pre>

<h4>列表</h4>

<p>无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的.</p>

<p>常用语法：</p>

<table border=4 width=400 align=center bordercolor=red>
    <tr>
        <td>输出后的效果  </td>
        <td>Markdown    </td>
        <td>快捷键   </td>
        <td>是否好用    </td>       
    </tr>
    <tr>
        <td>List    </td>
        <td>* item  </td>
        <td>Ctrl + L</td>
        <td>好用  </td>
    </tr>
     <tr>
        <td>List    </td>
        <td>+ item  </td>
        <td></td>
        <td></td>
    </tr>
     <tr>
        <td>List    </td>
        <td>- item  </td>
        <td></td>
        <td></td>
    </tr>
     <tr>
        <td>List    </td>
        <td>1 item  </td>
        <td></td>
        <td></td>
    </tr>
    </table>


<p>星号</p>

<pre><code>* Candy.
* Gum.
* Booze.    
</code></pre>

<p>加号</p>

<pre><code>+ Candy.
+ Gum.
+ Booze.    
</code></pre>

<p>和减号</p>

<pre><code>- Candy.
- Gum.
- Booze.
</code></pre>

<p>都会输出 HTML 为：</p>

<pre><code>&lt;ul&gt;
    &lt;li&gt;Candy.&lt;/li&gt;
    &lt;li&gt;Gum.&lt;/li&gt;
    &lt;li&gt;Booze.&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>有序的列表则是使用一般的数字接着一个英文句点作为项目标记</p>

<pre><code>1. Red
2. Green
3. Blue
</code></pre>

<p>输出 HTML 为：</p>

<pre><code>&lt;ol&gt;
&lt;li&gt;Red&lt;/li&gt;
&lt;li&gt;Green&lt;/li&gt;
&lt;li&gt;Blue&lt;/li&gt;
&lt;/ol&gt;
</code></pre>

<h4>链接</h4>

<p>Markdown 支援两种形式的链接语法： 行内 和 参考 两种形式，两种都是使用角括号来把文字转成连结。</p>

<p>常用语法</p>

<table border=4 width=400 align=center bordercolor=red>
    <tr>
        <td>输出后的效果  </td>
        <td>Markdown    </td>
        <td>快捷键   </td>       
    </tr>
    <tr>
        <td>Link    </td>
        <td>[title](http://)    </td>
        <td></td>
    <tr>
    </table>


<p>行内形式是直接在后面用括号直接接上链接：</p>

<pre><code>This is an [example link](http://example.com/).
</code></pre>

<p>输出 HTML 为</p>

<pre><code>&lt;p&gt;This is an &lt;a href="http://example.com/"&gt;example link&lt;/a&gt;.&lt;/p&gt;
</code></pre>

<p>你也可以选择性的加上 title 属性：</p>

<pre><code>This is an [example link](http://example.com/ "With a Title").
</code></pre>

<p>输出 HTML 为</p>

<pre><code>&lt;p&gt;This is an &lt;a href="http://example.com/" title="With a Title"&gt;example link&lt;/a&gt;.&lt;/p&gt;
</code></pre>

<p>参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：</p>

<pre><code>I get 10 times more traffic from [Google][1] than from[Yahoo][2] or [MSN][3].

[1]: http://google.com/ "Google"
[2]: http://search.yahoo.com/ "Yahoo Search"
[3]: http://search.msn.com/ "MSN Search"
</code></pre>

<p>输出 HTML 为：</p>

<pre><code>&lt;p&gt;I get 10 times more traffic from &lt;a href="http://google.com/"title="Google"&gt;Google&lt;/a&gt; than from &lt;a href="http://search.yahoo.com/"title="Yahoo Search"&gt;Yahoo&lt;/a&gt; or &lt;a href="http://search.msn.com/"title="MSN Search"&gt;MSN&lt;/a&gt;.&lt;/p&gt;
</code></pre>

<p>title 属性是选择性的，链接名称可以用字母、数字和空格，但是<strong>不分大小写</strong>：</p>

<pre><code>I start my morning with a cup of coffee and [The New York Times][NY Times].

[ny times]: http://www.nytimes.com/
</code></pre>

<p>输出 HTML 为：</p>

<pre><code>&lt;p&gt;I start my morning with a cup of coffee and&lt;a href="http://www.nytimes.com/"&gt;The New York Times&lt;/a&gt;.&lt;/p&gt;
</code></pre>

<h4>代码</h4>

<p>常用语法</p>

<table border=4 width=400 align=center bordercolor=red>
    <tr>
        <td>输出后的效果  </td>
        <td>Markdown    </td>
        <td>快捷键   </td>
        <td>是否好用    </td>               
    </tr>
    <tr>
        <td>Inline Code     </td>
        <td>`code`  </td>
        <td>⌘ + K</td>
        <td>好用</td>
    <tr>
    </table>


<p>在一般的段落文字中，你可以使用反引号 ` 来标记代码区段，区段内的 &amp;、&lt; 和 > 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：</p>

<pre><code>I strongly recommend against using any `&lt;blink&gt;` tags.I wish SmartyPants used named entities like `&amp;mdash;`instead of decimal-encoded entites like `&amp;#8212;`.
</code></pre>

<p>输出 HTML 为：</p>

<pre><code>&lt;p&gt;I strongly recommend against using any&lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;&lt;p&gt;I wish SmartyPants used named entities like&lt;code&gt;&amp;amp;mdash;&lt;/code&gt; instead of decimal-encodedentites like &lt;code&gt;&amp;amp;#8212;&lt;/code&gt;.&lt;/p&gt;
</code></pre>

<h3>图片</h3>

<blockquote><p>图片的语法和链接很像。</p></blockquote>

<p>行内形式（title 是选择性的）：</p>

<pre><code>![alt text](/images/email.png "Title")
</code></pre>

<p>结果</p>

<p><img src="http://npopensource.github.io/images/email.png" title="Title" alt="alt text" /></p>

<p>参考形式：</p>

<pre><code>![alt text][id]
[id]: /images/email.png "Title" 
</code></pre>

<p>结果</p>

<p><img src="http://npopensource.github.io/images/email.png" title="Title" alt="alt text" /></p>

<blockquote><p>  提示：github引用图片资源应该放在octopress/source/images/</p></blockquote>

<h4>table</h4>

<p>markdown 生成table 可以直接用html标签 相对比较麻烦 （github 不支持表格）</p>

<pre><code>&lt;table border=4 width=250 align=center bordercolor=red&gt;
&lt;tr&gt;
    &lt;td&gt;北京  &lt;/td&gt;
    &lt;td&gt;雾霾  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;深圳  &lt;/td&gt;
    &lt;td&gt;暴雨  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

只有width 起作用
</code></pre>

<p>响应的效果</p>

<table border=4 width=250 align=center bordercolor=red>
    <tr>
        <td>北京  </td>
        <td>雾霾  </td>
    </tr>
    <tr>
        <td>深圳  </td>
        <td>暴雨  </td>
    </tr>
    </table>


<h4>文本样式</h4>

<ul>
<li>链接 :<a href="URL">Title</a></li>
<li>加粗 :<strong>Bold</strong></li>
<li>斜体字 :<em>Italics</em></li>
<li>删除线 :<del>text</del></li>
<li>高亮 :==text==</li>
<li>段落 : 段落之间空一行</li>
<li>换行符 : 一行结束时输入两个空格</li>
<li>列表 :* 添加星号成为一个新的列表项。</li>
<li>引用 :> 引用内容</li>
<li>内嵌代码 : <code>alert('Hello World');</code></li>
<li>画水平线 (HR) :&mdash;&mdash;&ndash;</li>
</ul>


<h5>参考链接：</h5>

<ul>
<li><a href="http://wowubuntu.com/markdown/basic.html">http://wowubuntu.com/markdown/basic.html</a></li>
<li><a href="http://baike.baidu.com/link?url=tyTi8BEbR9O32Af2md0WHPGdFwH_ZGSU0oVORrowucw1Nw8OWiuEJOoGeihjIcy5DH9tJCD-8s0RLPIaZKfeaa">markdown百度百科</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[博客的第一天]]></title>
    <link href="http://npopensource.github.io/blog/2015/07/31/%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <updated>2015-07-31T11:52:07+08:00</updated>
    <id>http://npopensource.github.io/blog/2015/07/31/博客第一天</id>
    <content type="html"><![CDATA[<h1>新的一天新的开始。只有不断的学习不断的积累才能强大自己。加油。</h1>
]]></content>
  </entry>
  
</feed>
