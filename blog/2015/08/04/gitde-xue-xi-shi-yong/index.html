
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Git的学习使用 - 温杰的博客</title>
  <meta name="author" content="温杰">

  
  <meta name="description" content="git原理(最好自己实践敲下代码) 底层命令 (Plumbing) 和高层命令 (Porcelain) 用github 不得不学习下 git 命令行。 要想学好git ，我认为，首先要弄懂git 原理，接着熟练掌握git 命令行。 本文讲解了使用 checkout, branch, remote &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://npopensource.github.io/blog/2015/08/04/gitde-xue-xi-shi-yong/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="温杰的博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.useso.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">温杰的博客</a></h1>
  
    <h2>不积跬步无以至千里,不积小流无以成江海</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.baidu.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="npopensource.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">ios相关</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Git的学习使用</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-04T16:33:09+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:33 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><h2>git原理(最好自己实践敲下代码)</h2>

<blockquote><p>底层命令 (Plumbing) 和高层命令 (Porcelain)</p></blockquote>

<p>用github 不得不学习下 git 命令行。 要想学好git ，我认为，首先要弄懂git 原理，接着熟练掌握git 命令行。</p>

<p>本文讲解了使用 checkout, branch, remote 等共约 30 个 Git 命令。然而由于 Git 一开始被设计成供 VCS 使用的工具集而不是一整套用户友好的 VCS，它还包含了许多底层命令，这些命令用于以 UNIX 风格使用或由脚本调用。这些命令一般被称为 “plumbing” 命令（底层命令），其他的更友好的命令则被称为 “porcelain” 命令（高层命令）。</p>

<p>当你在一个新目录或已有目录内执行 git init 时，Git 会创建一个 .git 目录，几乎所有 Git 存储和操作的内容都位于该目录下。如果你要备份或复制一个库，基本上将这一目录拷贝至其他地方就可以了。本章基本上都讨论该目录下的内容。该目录结构如下：</p>

<pre><code>$ ls HEAD branches/ config description hooks/ index info/ objects/ refs/
</code></pre>

<p>该目录下有可能还有其他文件，但这是一个全新的 git init 生成的库，所以默认情况下这些就是你能看到的结构。新版本的 Git 不再使用branches 目录，description 文件仅供 GitWeb 程序使用，所以不用关心这些内容。config 文件包含了项目特有的配置选项，info 目录保存了一份不希望在 .gitignore 文件中管理的忽略模式 (ignored patterns) 的全局可执行文件。hooks 。</p>

<p><strong>另外还有四个重要的文件或目录：HEAD 及 index 文件，objects 及refs 目录。这些是 Git 的核心部分。objects 目录存储所有数据内容，refs 目录存储指向数据 (分支) 的提交对象的指针，HEAD 文件指向当前分支，index 文件保存了暂存区域信息。</strong></p>

<blockquote><p>Git 对象</p></blockquote>

<p><strong>Git 是一套内容寻址文件系统</strong>。这种说法的意思是，从内部来看，Git 是简单的 key-value 数据存储。它允许插入任意类型的内容，并会返回一个键值，通过该键值可以在任何时候再取出该内容。可以通过底层命令hash-object 来示范这点，传一些数据给该命令，它会将数据保存在 .git 目录并返回表示这些数据的键值。首先初使化一个 Git 仓库并确认objects 目录是空的：</p>

<pre><code>$ mkdir test
 $ cd test
 $ git init 

 Initialized empty Git repository in /tmp/test/.git/ 
 $ find .git/objects
  .git/objects 
  .git/objects/info 
  .git/objects/pack 
  $ find .git/objects -type f 
</code></pre>

<p>Git 初始化了 objects 目录，同时在该目录下创建了 pack 和 info 子目录，但是该目录下没有其他常规文件。我们往这个 Git 数据库里存储一些文本：</p>

<pre><code>$ echo 'test content' | git hash-object -w --stdin 
d670460b4b4aece5915caf5c68d12f560a9fe3e4
</code></pre>

<p>参数 -w 指示 hash-object 命令存储 (数据) 对象，若不指定这个参数该命令仅仅返回键值。&ndash;stdin 指定从标准输入设备 (stdin) 来读取内容，若不指定这个参数则需指定一个要存储的文件的路径。该命令输出长度为 40 个字符的校验和。这是个 SHA-1 哈希值──其值为要存储的数据加上你马上会了解到的一种头信息的校验和。现在可以查看到 Git 已经存储了数据</p>

<pre><code>$ find .git/objects -type f 
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
</code></pre>

<p>可以在 objects 目录下看到一个文件。这便是 Git 存储数据内容的方式──为每份内容生成一个文件，取得该内容与头信息的 SHA-1 校验和，创建以该校验和前两个字符为名称的子目录，并以 (校验和) 剩下 38 个字符为文件命名 (保存至子目录下)。</p>

<p>通过 cat-file 命令可以将数据内容取回。该命令是查看 Git 对象的瑞士军刀。传入 -p 参数可以让该命令输出数据内容的类型</p>

<pre><code>$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4 
test content
</code></pre>

<p>可以往 Git 中添加更多内容并取回了。也可以直接添加文件。比方说可以对一个文件进行简单的版本控制。首先，创建一个新文件，并把文件内容存储到数据库中：</p>

<pre><code>$ echo 'version 1' &gt; test.txt
 $ git hash-object -w test.txt 83baae61804e65cc73a7201a7252750c76066a30
</code></pre>

<p> 接着往该文件中写入一些新内容并再次保存</p>

<pre><code>    $ echo 'version 2' &gt; test.txt
    $ git hash-object -w test.txt 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
</code></pre>

<p> 数据库中已经将文件的两个新版本连同一开始的内容保存下来了：</p>

<pre><code> $ find .git/objects -type f 
 .git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a 
 .git/objects/83/baae61804e65cc73a7201a7252750c76066a30 
 .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
</code></pre>

<p>再将文件恢复到第一个版本</p>

<pre><code>$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt
 $ cat test.txt 
 version 1
</code></pre>

<p> 或恢复到第二个版本：</p>

<pre><code> $ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt 
 $ cat test.txt 
    version 2
</code></pre>

<p>需要记住的是几个版本的文件 SHA-1 值可能与实际的值不同，其次，存储的并不是文件名而仅仅是文件内容。这种对象类型称为 blob 。通过传递 SHA-1 值给cat-file -t 命令可以让 Git 返回任何对象的类型：</p>

<pre><code>$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a 
blob
</code></pre>

<blockquote><p>tree (树) 对象</p></blockquote>

<p>接下去来看 tree 对象，tree 对象可以存储文件名，同时也允许存储一组文件。Git 以一种类似 UNIX 文件系统但更简单的方式来存储内容。所有内容以 tree 或 blob 对象存储，其中 tree 对象对应于 UNIX 中的目录，blob 对象则大致对应于 inodes 或文件内容。一个单独的 tree 对象包含一条或多条 tree 记录，每一条记录含有一个指向 blob 或子 tree 对象的 SHA-1 指针，并附有该对象的权限模式 (mode)、类型和文件名信息。以 simplegit 项目为例，最新的 tree 可能是这个样子：</p>

<pre><code>    $ git cat-file -p master^{tree} 100644 blob a906cb2a4a904a152e80877d4088654daad0c859 README 100644 blob 8f94139338f9404f26296befa88755fc2598c289 Rakefile 040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0 lib

    具体生成办法往下看，这个代码可以暂时不验证     
</code></pre>

<p>master^{tree} 表示 branch 分支上最新提交指向的 tree 对象。请注意 lib 子目录并非一个 blob 对象，而是一个指向别一个 tree 对象的指针：</p>

<pre><code>$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0 100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b simplegit.rb
</code></pre>

<p>从概念上来讲，Git 保存的数据如图
<img src="/images/git-branch32.png" alt="alt text" /></p>

<p>你可以自己创建 tree 。通常 Git 根据你的暂存区域或 index 来创建并写入一个 tree 。因此要创建一个 tree 对象的话首先要通过将一些文件暂存从而创建一个 index 。可以使用 plumbing 命令update-index 为一个单独文件 ── test.txt 文件的第一个版本 ──    创建一个 index    。通过该命令人为的将 test.txt 文件的首个版本加入到了一个新的暂存区域中。由于该文件原先并不在暂存区域中 (甚至就连暂存区域也还没被创建出来呢) ，必须传入&ndash;add 参数;由于要添加的文件并不在当前目录下而是在数据库中，必须传入 &ndash;cacheinfo 参数。同时指定了文件模式，SHA-1 值和文件名：</p>

<pre><code>$ git update-index --add --cacheinfo 100644  83baae61804e65cc73a7201a7252750c76066a30 test.txt
</code></pre>

<p>在本例中，指定了文件模式为 100644，表明这是一个普通文件。其他可用的模式有：100755 表示可执行文件，120000 表示符号链接。文件模式是从常规的 UNIX 文件模式中参考来的，但是没有那么灵活 ── 上述三种模式仅对 Git 中的文件 (blobs) 有效 (虽然也有其他模式用于目录和子模块)。</p>

<p>现在可以用 write-tree 命令将暂存区域的内容写到一个 tree 对象了。无需 -w 参数 ── 如果目标 tree 不存在，调用write-tree 会自动根据 index 状态创建一个 tree 对象。</p>

<pre><code>$ git write-tree 
d8329fc1cc938780ffdd9f94e0d364e0ea74f579 
$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
 100644 blob 83baae61804e65cc73a7201a7252750c76066a30 test.txt
</code></pre>

<p>可以这样验证这确实是一个 tree 对象</p>

<pre><code>$ git cat-file -t 
d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree
</code></pre>

<p>再根据 test.txt 的第二个版本以及一个新文件创建一个新 tree 对象：</p>

<pre><code>$ echo 'new file' &gt; new.txt
 $ git update-index test.txt 
 $ git update-index --add new.txt
</code></pre>

<p>这时暂存区域中包含了 test.txt 的新版本及一个新文件 new.txt 。创建 (写) 该 tree 对象 (将暂存区域或 index 状态写入到一个 tree 对象)，然后瞧瞧它的样子</p>

<pre><code>$ git write-tree 
0155eb4229851634a0f03eb265b69f5a2d56f341 
$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
 100644 blob fa49b077972391ad58037050f2a75f74e3671e92 new.txt 100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt
</code></pre>

<p>请注意该 tree 对象包含了两个文件记录，且 test.txt 的 SHA 值是早先值的 “第二版” (1f7a7a)。来点更有趣的，你将把第一个 tree 对象作为一个子目录加进该 tree 中。可以用read-tree 命令将 tree 对象读到暂存区域中去。在这时，通过传一个 &ndash;prefix 参数给 read-tree，将一个已有的 tree 对象作为一个子 tree 读到暂存区域中</p>

<pre><code>$ git read-tree --prefix=bak
 d8329fc1cc938780ffdd9f94e0d364e0ea74f579
  $ git write-tree
   3c4e9cd789d88d8d89c1073707c3585e41b0e614 
   $ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614 
   040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579 bak 100644 blob fa49b077972391ad58037050f2a75f74e3671e92 new.txt 100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt
</code></pre>

<p>如果从刚写入的新 tree 对象创建一个工作目录，将得到位于工作目录顶级的两个文件和一个名为 bak 的子目录，该子目录包含了 test.txt 文件的第一个版本。可以将 Git 用来包含这些内容的数据想象成如图  所示的样子
    <img src="/images/git-branch40.png" alt="alt text" /></p>

<blockquote><p>commit (提交) 对象</p></blockquote>

<p>你现在有三个 tree 对象，它们指向了你要跟踪的项目的不同快照，可是先前的问题依然存在：必须记往三个 SHA-1 值以获得这些快照。你也没有关于谁、何时以及为何保存了这些快照的信息。commit 对象为你保存了这些基本信息。</p>

<p>要创建一个 commit 对象，使用 commit-tree 命令，指定一个 tree 的 SHA-1，如果有任何前继提交对象，也可以指定。从你写的第一个 tree 开始：</p>

<pre><code>$ echo 'first commit' | git commit-tree d8329f
 fdf4fc3344e67ab068f836878b6c4951e3b15f3d
</code></pre>

<p>通过 cat-file 查看这个新 commit 对象</p>

<pre><code>$ git cat-file -p fdf4fc3 
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579 author Scott Chacon 1243040974 -0700 committer Scott Chacon 1243040974 -0700 first commit 
</code></pre>

<p>commit 对象有格式很简单：指明了该时间点项目快照的顶层树对象、作者/提交者信息（从 Git 设理发店的 user.name 和user.email中获得)以及当前时间戳、一个空行，以及提交注释信息。</p>

<p>接着再写入另外两个 commit 对象，每一个都指定其之前的那个 commit 对象</p>

<pre><code>$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3 
cac0cab538b970a37ea1e769cbbde608743bc96d
 $ echo 'third commit' | git commit-tree 3c4e9c -p cac0cab 
 1a410efbd13591db07496601ebc7a059dd55cfe9
</code></pre>

<p>每一个 commit 对象都指向了你创建的树对象快照。出乎意料的是，现在已经有了真实的 Git 历史了，所以如果运行 git log 命令并指定最后那个 commit 对象的 SHA-1 便可以查看历史：</p>

<pre><code>$ git log    --stat 1a410e 
commit 1a410efbd13591db07496601ebc7a059dd55cfe9 Author: Scott Chacon Date: Fri May 22 18:15:24 2009 -0700 third commit bak/test.txt | 1 + 1 files changed, 1 insertions(+), 0 deletions(-)
 commit cac0cab538b970a37ea1e769cbbde608743bc96d Author: Scott Chacon Date: Fri May 22 18:14:29 2009 -0700 second commit new.txt | 1 + test.txt | 2 +- 2 files changed, 2 insertions(+), 1 deletions(-)
  commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d Author: Scott Chacon Date: Fri May 22 18:09:34 2009 -0700 first commit test.txt | 1 + 1 files changed, 1 insertions(+), 0 deletions(-) 
</code></pre>

<p>真棒。你刚刚通过使用低级操作而不是那些普通命令创建了一个 Git 历史。这基本上就是运行    git add 和 git commit 命令时 Git 进行的工作    ──保存修改了的文件的 blob，更新索引，创建 tree 对象，最后创建 commit 对象，这些 commit 对象指向了顶层 tree 对象以及先前的 commit 对象。这三类 Git 对象 ── blob，tree 以及 tree ── 都各自以文件的方式保存在.git/objects 目录下。以下所列是目前为止样例中的所有对象，每个对象后面的注释里标明了它们保存的内容：</p>

<pre><code>$ find .git/objects -type f 
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2 .git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3 .git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2 .git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3 .git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1 .git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2 .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content' .git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1 .git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt .git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1
</code></pre>

<p>如果你按照以上描述进行了操作，可以得到如图所示的对象图</p>

<p><img src="/images/git-branch41.png" alt="alt text" /></p>

<h3>原理图</h3>

<p><img src="/images/git-yuanli.png" alt="alt text" />
这张图能比较直观的看出git 的工作原理和简单关键命令。</p>

<blockquote><p> 底层命令 (Plumbing) 和高层命令 (Porcelain)</p></blockquote>

<p>首先要弄明白一点，从根本上来讲 Git 是一套内容寻址 (content-addressable) 文件系统。</p>

<h3>git 目录</h3>

<p><img src="/images/git-mulu.png" alt="alt text" /></p>

<h3>关于版本控制（可以不看，讲述git的由来）</h3>

<blockquote><p>本地版本控制系统</p></blockquote>

<p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单。不过坏处也不少：有时候会混淆所在的工作目录，一旦弄错文件丢了数据就没法撤销恢复。</p>

<p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p>

<p><img src="/images/git-local.png" title="本地版本控制" alt="alt text" /></p>

<p>其中最流行的一种叫做 rcs，现今许多计算机系统上都还看得到它的踪影。甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。它的工作原理基本上就是保存并管理文件补丁（patch）。文件补丁是一种特定格式的文本文件，记录着对应文件修订前后的内容变化。所以，根据每次 修订后的补丁，rcs 可以通过不断打补丁，计算出各个版本的文件内容。</p>

<blockquote><p>集中化的版本控制系统</p></blockquote>

<p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统（ Centralized Version Control Systems，简称 CVCS ）应运而生。这类系统，诸如 CVS，Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这 已成为版本控制系统的标准做法</p>

<p><img src="/iamges/git-morepeople.png" alt="alt text" /></p>

<p>这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p>

<p>事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要 是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就还是会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，而被客户端 提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完整提取出来过。本地版本控制系统也存在类似问题，只要整个项 目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险</p>

<blockquote><p>分布式版本控制系统</p></blockquote>

<p>于是分布式版本控制系统（ Distributed Version Control System，简称 DVCS ）面世了。在这类系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜 像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。</p>

<p><img src="/images/git-fenbushi.png" alt="alt text" /></p>

<p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p>

<h3>git基础</h3>

<blockquote><p>直接记录快照，而非差异比较</p></blockquote>

<p>Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统 （CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容</p>

<p><img src="/images/git-otherSys.png" alt="alt text" /></p>

<p>Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照 的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。</p>

<p><img src="/images/git-differentSys.png" alt="alt text" /></p>

<p>这是 Git 同其他系统的重要区别。它完全颠覆了传统版本控制的套路，并对各个环节的实现方式作了新的设计。Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的 VCS</p>

<blockquote><p>近乎所有操作都是本地执行</p></blockquote>

<p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVCS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。
    举个例子，如果要浏览项目的历史更新摘要，Git 不用跑到外面的服务器上去取数据回来，而直接从本地数据库读取后展示给你看。所以任何时候你都可以马上翻阅，无需等待。如果想要看当前版本的文件和一个月 前的版本之间有何差异，Git 会取出一个月前的快照和当前文件作一次差异运算，而不用请求远程服务器来做这件事，或是把老版本的文件拉到本地来作比较。</p>

<blockquote><p>时刻保持数据完整性</p></blockquote>

<p>在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。</p>

<p>Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是：</p>

<p>24b9da6552252987aa493b52f8696cd6d3b00373</p>

<p>Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。</p>

<blockquote><p>多数操作仅添加数据</p></blockquote>

<p>常用的 Git 操作大多仅仅是把数据添加到数据库。因为任何一种不可逆的操作，比如删除数据，都会使回退或重现历史版本变得困难重重。在别的 VCS 中，若还未提交更新，就有可能丢失或者混淆一些修改的内容，但在 Git 里，一旦提交快照之后就完全不用担心丢失数据，特别是养成定期推送到其他仓库的习惯的话。</p>

<blockquote><p>文件的三种状态</p></blockquote>

<p>好，现在请注意，接下来要讲的概念非常重要。对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库 中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。</p>

<p>由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。</p>

<p><img src="/images/git-option.png" alt="alt text" /></p>

<p>每个项目都有一个 Git 目录（译注：如果 git clone 出来的话，就是其中 .git 的目录；如果git clone &ndash;bare 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。</p>

<p>从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。</p>

<p>所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。</p>

<p>基本的 Git 工作流程如下：</p>

<ol>
<li><p>在工作目录中修改某些文件。 2. 对修改后的文件进行快照，然后保存到暂存区域。 3. 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</p>

<p> 所以，我们可以从文件所处的位置来判断状态：如果是 Git 目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就 是已修改状态。</p></li>
</ol>


<p>请记住，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记 录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存 区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p>

<p>在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。所以使用 Git 时的文件状态变化周期如图
<img src="/images/git-change.png" alt="alt text" /></p>

<h3>git 分支</h3>

<blockquote><p> 何谓分支</p></blockquote>

<p>为了理解 Git 分支的实现方式，我们需要回顾一下 Git 是如何储存数据的。或许你还记得第一章的内容，Git 保存的不是文件差异或者变化量，而只是一系列文件快照。</p>

<p>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对 象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p>

<p>为直观起见，我们假设在工作目录中有三个文件，准备将它们暂存后提交。暂存操作会对每一个文件计算校验和，然后把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 类型的对象存储这些快照），并将校验和加入暂存区域：</p>

<pre><code>$ git add README test.rb LICENSE $ git commit -m 'initial commit of my project'
</code></pre>

<p>当使用 git commit 新建一个提交对象前，Git 会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在 Git 仓库中将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。</p>

<p>现在，Git 仓库中有五个对象：三个表示文件快照内容的 blob 对象；一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象；以及一个包含指向 tree 对象（根目录）的索引和其他提交信息元数据的 commit 对象。概念上来说，仓库中的各个对象保存的数据和相互关系看起来如图：
<img src="/images/git-branch-master.png" alt="alt text" /></p>

<p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（译注：即下图中的 parent 对象）。两次提交后，仓库历史会变成下图</p>

<p><img src="/iamges/git-commit-more.png" alt="alt text" /></p>

<p>现在来谈分支。Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 master 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。</p>

<p><img src="/images/git-branch-new.png" alt="alt text" /></p>

<p>Git 又是如何创建一个新的分支的呢？答案很简单，创建一个新的分支指针。比如新建一个 testing 分支，可以使用 git branch 命令：</p>

<pre><code>$ git branch testing
</code></pre>

<p>这会在当前 commit 对象上新建一个分支指针如图</p>

<p><img src="/images/git-branch-create.png" alt="alt text" /></p>

<p>那么，Git 是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为 HEAD 的特别指针。请注意它和你熟知的许多其他版本控制系统（比如 Subversion 或 CVS）里的 HEAD 概念大不相同。在 Git 中，它是一个指向你正在工作中的本地分支的指针（译注：将 HEAD 想象为当前分支的别名。）。运行git branch 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在 master 分支里工作(如图)</p>

<p><img src="/images/git-branch-show.png" alt="alt text" /></p>

<p>要切换到其他分支，可以执行 git checkout 命令。我们现在转换到新建的 testing 分支</p>

<pre><code>$ git checkout testing
</code></pre>

<p>这样 HEAD 就指向了 testing 分支</p>

<p><img src="/images/git-branch-check.png" alt="alt text" /></p>

<p>这样的实现方式会给我们带来什么好处呢？好吧，现在不妨再提交一次：</p>

<pre><code>$ vim test.rb $ git commit -a -m 'made a change'
</code></pre>

<p>下图  展示了提交后的结果</p>

<p><img src="/images/git-branch-checkout.png" alt="alt text" /></p>

<p>非常有趣，现在 testing 分支向前移动了一格，而 master 分支仍然指向原先 git checkout 时所在的 commit 对象。现在我们回到 master 分支看看：</p>

<pre><code>$ git checkout master
</code></pre>

<p>下图 显示了结果。</p>

<p><img src="/images/git-master-new.png" alt="alt text" /></p>

<p>这条命令做了两件事。它把 HEAD 指针移回到 master 分支，并把工作目录中的文件换成了 master 分支所指向的快照内容。也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。</p>

<p>我们作些修改后再次提交：</p>

<pre><code>$ vim test.rb $ git commit -a -m 'made other changes'
</code></pre>

<p>现在我们的项目提交历史产生了分叉（如图 3-9 所示），因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以 在不同分支里反复切换，并在时机成熟时把它们合并到一起。而所有这些工作，仅仅需要branch 和 checkout 这两条命令就可以完成。</p>

<p><img src="/images/git-head.png" alt="alt text" /></p>

<p>由于 Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，当然也就很快了。</p>

<p>这和大多数版本控制系统形成了鲜明对比，它们管理分支大多采取备份所有项目文件到特定目录的方式，所以根据项目文件数量和大小不同，可能花费的时间 也会有相当大的差别，快则几秒，慢则数分钟。而 Git 的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。同时，因为每次提交时都记录了祖先信息（译注：即parent 对象），将来要合并分支时，寻找恰当的合并基础（译注：即共同祖先）的工作其实已经自然而然地摆在那里了，所以实现起来非常容易。Git 鼓励开发者频繁使用分支，正是因为有着这些特性作保障</p>

<blockquote><p>  分支的新建与合并</p></blockquote>

<p>现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程：</p>

<p> 开发某个网站。 2. 为实现某个新的需求，创建一个分支。 3. 在这个分支上开展工作。</p>

<p>假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理：</p>

<ol>
<li>返回到原先已经发布到生产服务器上的分支。 2. 为这次紧急修补建立一个新分支，并在其中修复问题。 3. 通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。 4. 切换到之前实现新需求的分支，继续工作。</li>
</ol>


<p><strong>分支的新建与切换</strong></p>

<p>首先，我们假设你正在项目中愉快地工作，并且已经提交了几次更新
<img src="/images/git-branch1.png" alt="alt text" /></p>

<p>现在，你决定要修补问题追踪系统上的 #53 问题。顺带说明下，Git 并不同任何特定的问题追踪系统打交道。这里为了说明要解决的问题，才把新建的分支取名为 iss53。要新建并切换到该分支，运行git checkout 并加上 -b 参数：</p>

<pre><code>$ git checkout -b iss53 
 Switched to a new branch "iss53"
</code></pre>

<p>这相当于执行下面这两条命令：</p>

<pre><code>$ git branch iss53 $ git checkout iss53
</code></pre>

<p>图 示意该命令的执行结果。</p>

<p><img src="/images/git-branch2.png" alt="alt text" /></p>

<p>接着你开始尝试修复问题，在提交了若干次更新后，iss53 分支的指针也会随着向前推进，因为它就是当前分支（换句话说，当前的 HEAD 指针正指向 iss53，见图 ）：</p>

<pre><code>$ vim index.html $ git commit -a -m 'added a new footer [issue 53]'
</code></pre>

<p><img src="/images/git-branch3.png" alt="alt text" /></p>

<p>现在你就接到了那个网站问题的紧急电话，需要马上修补。有了 Git ，我们就不需要同时发布这个补丁和 iss53 里作出的修改，也不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改。唯一需要的仅仅是切换回master 分支。</p>

<p>不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支。切换分支的时候最好保持一个清洁的工作区域。稍后会介绍几个绕过这种问题的办法（分别叫做 stashing 和 commit amending）。目前已经提交了所有的修改，所以接下来可以正常转换到master 分支：</p>

<pre><code>$ git checkout master Switched to branch "master"
</code></pre>

<p>此时工作目录中的内容和你在解决问题 #53 之前一模一样，你可以集中精力进行紧急修补。这一点值得牢记：Git 会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样</p>

<p>接下来，你得进行紧急修补。我们创建一个紧急修补分支 hotfix 来开展工作，直到搞定（见图 3-13）：</p>

<pre><code>$ git checkout -b 'hotfix'
 $ vim index.html $ git commit -a -m 'fixed "
</code></pre>

<p> <img src="/images/git-branch6.png" alt="alt text" /></p>

<p> 有必要作些测试，确保修补是成功的，然后回到 master 分支并把它合并进来，然后发布到生产服务器。用 git merge 命令来进行合并</p>

<pre><code>$ git checkout master 
$ git merge hotfix
</code></pre>

<p>请注意，合并时出现了“Fast forward”的提示。由于当前 master 分支所在的提交对象是要并入的 hotfix 分支的直接上游，Git 只需把master 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</p>

<p>现在最新的修改已经在当前 master 分支所指向的提交对象中了，可以部署到生产服务器上去了
<img src="/images/git-branch5.png" alt="alt text" />
在那个超级重要的修补发布以后，你想要回到被打扰之前的工作。由于当前 hotfix 分支和 master 都指向相同的提交对象，所以hotfix 已经完成了历史使命，可以删掉了。使用 git branch 的 -d 选项执行删除操作：</p>

<pre><code>$ git branch -d hotfix Deleted branch hotfix (3a0874c).
</code></pre>

<p>现在回到之前未完成的 #53 问题修复分支上继续工作</p>

<pre><code>$ git checkout iss53
$ vim index.html $ git commit -a -m "new content"
</code></pre>

<p><img src="/images/git-branch6.png" alt="alt text" /></p>

<p>不用担心之前 hotfix 分支的修改内容尚未包含到 iss53 中来。如果确实需要纳入此次修补，可以用git merge master 把 master 分支合并到 iss53；或者等 iss53 完成之后，再将iss53 分支中的更新并入 master</p>

<ul>
<li>分支的合并</li>
</ul>


<p>在问题 #53 相关的工作完成之后，可以合并回 master 分支。实际操作同前面合并 hotfix 分支差不多，只需回到master 分支，运行 git merge 命令指定要合并进来的分支：</p>

<pre><code>$ git checkout master 
$ git merge iss53
</code></pre>

<p>请注意，这次合并操作的底层实现，并不同于之前 hotfix 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 master 分支所指向的提交对象（C4）并不是 iss53 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。图 3-16 用红框标出了 Git 用于合并的三个提交对象</p>

<p><img src="/images/git-branch7.png" alt="alt text" /></p>

<p>这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</p>

<p>值得一提的是 Git 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 Git 的合并操作比其他系统都要简单不少</p>

<p><img src="/images/git-branch8.png" alt="alt text" /></p>

<p>既然之前的工作成果已经合并到 master 了，那么 iss53 也就没用了。你可以就此删除它，并在问题追踪系统里关闭该问题。</p>

<pre><code>$ git branch -d iss53
</code></pre>

<ul>
<li>遇到冲突时的分支合并</li>
</ul>


<p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题 #53 的过程中修改了hotfix 中修改的部分，将得到类似下面的结果</p>

<pre><code>$ git merge iss53 Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result.
</code></pre>

<p>Git 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 git status 查阅</p>

<pre><code>[master*]$ git status index.html: needs merge # On branch master # Changed but not updated: # (use "git add ..." to update what will be committed) # (use "git checkout -- ..." to discard changes in working directory) # # unmerged: index.html #     
</code></pre>

<p>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：</p>

<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html 
contact : email.support@github.com
======= 
please contact us at support@github.com
&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html
</code></pre>

<p>可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行merge 命令时所切换到的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决</p>

<pre><code>please contact us at email.support@github.com
</code></pre>

<p>这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 >>>>>>> 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。因为一旦暂存，就表示冲突已经解决。如果你想用一个有图形界面的工具来解决这些问题，不妨运行git mergetool，它会调用一个可视化的合并工具并引导你解决所有冲突：</p>

<pre><code>$ git mergetool merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff Merging the files: index.html Normal merge conflict for 'index.html': {local}: modified {remote}: modified Hit return to start merge resolution tool (opendiff):
</code></pre>

<p>如果不想用默认的合并工具（Git 为我默认选择了 opendiff，因为我在 Mac 上运行了该命令），你可以在上方”merge tool candidates”里找到可用的合并工具列表，输入你想用的工具名。我们将在第七章讨论怎样改变环境中的默认值。</p>

<p>退出合并工具以后，Git 会询问你合并是否成功。如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。</p>

<p>再运行一次 git status 来确认所有冲突都已解决：</p>

<pre><code>$ git status # On branch master # Changes to be committed: # (use "git reset HEAD ..." to unstage) # # modified: index.html # 
</code></pre>

<p>如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用 git commit 来完成这次合并提交。提交的记录差不多是这样：</p>

<pre><code>Merge branch 'iss53' Conflicts: index.html # # It looks like you may be committing a MERGE. # If this is not correct, please remove the file # .git/MERGE_HEAD # and try again. #
</code></pre>

<p>如果想给将来看这次合并的人一些方便，可以修改该信息，提供更多合并细节。比如你都作了哪些改动，以及这么做的原因。有时候裁决冲突的理由并不直接或明显，有必要略加注解。</p>

<ul>
<li>分支的管理</li>
</ul>


<p>到目前为止，你已经学会了如何创建、合并和删除分支。除此之外，我们还需要学习如何管理分支，在日后的常规工作中会经常用到下面介绍的管理命令</p>

<p>git branch 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单</p>

<pre><code>$ git branch iss53 * master testing
</code></pre>

<p>注意看 master 分支前的 * 字符：它表示当前所在的分支。也就是说，如果现在提交更新，master 分支将随着开发进度前移。若要查看各个分支最后一个提交对象的信息，运行git branch -v</p>

<pre><code>$ git branch -v iss53 93b412c fix javascript issue * master 7a98805 Merge branch 'iss53' testing 782fd34 add scott to the author list in the readmes
</code></pre>

<p>要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用 &ndash;merge 和 &ndash;no-merged 选项（Git 1.5.6 以上版本）。比如用git branch &ndash;merge 查看哪些分支已被并入当前分支（译注：也就是说哪些分支是当前分支的直接上游。）：</p>

<pre><code>$ git branch --merged iss53 * master
</code></pre>

<p>之前我们已经合并了 iss53，所以在这里会看到它。一般来说，列表中没有 * 的分支通常都可以用 git branch -d 来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么。</p>

<p>另外可以用 git branch &ndash;no-merged 查看尚未合并的工作：</p>

<pre><code>$ git branch --no-merged testing
</code></pre>

<p>它会显示还未合并进来的分支。由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用 git branch -d 删除该分支会提示错误，因为那样做会丢失数据</p>

<pre><code>$ git branch -d testing error: The branch 'testing' is not an ancestor of your current HEAD. If you are sure you want to delete it, run 'git branch -D testing'.
</code></pre>

<p>不过，如果你确实想要删除该分支上的改动，可以用大写的删除选项 -D 强制执行，就像上面提示信息中给出的那样。</p>

<blockquote><p>利用分支进行开发的工作流程</p></blockquote>

<ul>
<li>长期分支</li>
</ul>


<p>由于 Git 使用简单的三方合并，所以就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不是什么难事。也就是说，你可以同时拥有多个开放的分支，每个分支用于完成特定的任务，随着开发的推进，你可以随时把某个特性分支的成果并到其他分支中。</p>

<p>许多使用 Git 的开发者都喜欢用这种方式来开展工作，比如仅在 master 分支中保留完全稳定的代码，即已经发布或即将发布的代码。与此同时，他们还有一个名为develop 或 next 的平行分支，专门用于后续的开发，或仅用于稳定性测试 — 当然并不是说一定要绝对稳定，不过一旦进入某种稳定状态，便可以把它合并到master 里。这样，在确保这些已完成的特性分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多错误之后，就可以并到主干分支中，等待下一次的发布</p>

<p>本质上我们刚才谈论的，是随着提交对象不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支总是比较靠前
<img src="/images/git-branch9.png" alt="alt text" /></p>

<p>或者把它们想象成工作流水线，或许更好理解一些，经过测试的提交对象集合被遴选到更稳定的流水线（见图 ）。</p>

<p><img src="/images/git-branch10.png" alt="alt text" /></p>

<p>你可以用这招维护不同层次的稳定性。某些大项目还会有个 proposed（建议）或 pu（proposed updates，建议更新）分支，它包含着那些可能还没有成熟到进入next 或 master 的内容。这么做的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。再次说明下，使用多个长期分支的做法并非必需，不过一般来说，对于特大型项目或特复杂的项目，这么做确实更容易管理。</p>

<ul>
<li>特性分支</li>
</ul>


<p>在任何规模的项目中都可以使用特性（Topic）分支。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。可能你在以前的版本控 制系统里从未做过类似这样的事情，因为通常创建与合并分支消耗太大。然而在 Git 中，一天之内建立、使用、合并再删除多个分支是常见的事。</p>

<p>我们在上节的例子里已经见过这种用法了。我们创建了 iss53 和 hotfix 这两个特性分支，在提交了若干更新后，把它们合并到主干分支，然后删除。该技术允许你迅速且完全的进行语境切换 — 因为你的工作分散在不同的流水线里，每个分支里的改变都和它的目标特性相关，浏览代码之类的事情因而变得更简单了。你可以把作出的改变保持在特性分支中几 分钟，几天甚至几个月，等它们成熟以后再合并，而不用在乎它们建立的顺序或者进度。</p>

<p>现在我们来看一个实际的例子。请看图 ，由下往上，起先我们在 master 工作到 C1，然后开始一个新分支 iss91 尝试修复 91 号缺陷，提交到 C6 的时候，又冒出一个解决该问题的新办法，于是从之前 C4 的地方又分出一个分支iss91v2，干到 C8 的时候，又回到主干 master 中提交了 C9 和 C10，再回到 iss91v2 继续工作，提交 C11，接着，又冒出个不太确定的想法，从 master 的最新提交 C10 处开了个新的分支dumbidea 做些试验。</p>

<p><img src="/images/git-branch11.png" alt="alt text" /></p>

<p>现在，假定两件事情：我们最终决定使用第二个解决方案，即 iss91v2 中的办法；另外，我们把 dumbidea 分支拿给同事们看了以后，发现它竟然是个天才之作。所以接下来，我们准备抛弃原来的iss91 分支（实际上会丢弃 C5 和 C6），直接在主干中并入另外两个分支。最终的提交历史将变成图 这样</p>

<p><img src="/images/git-branch12.png" alt="alt text" /></p>

<p>请务必牢记这些分支全部都是本地分支，这一点很重要。当你在使用分支及合并的时候，一切都是在你自己的 Git 仓库中进行的 — 完全不涉及与服务器的交互</p>

<blockquote><p>  远程分支</p></blockquote>

<p>远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。</p>

<p>我们用 (远程仓库名)/(分支名) 这样的形式表示远程分支。比如我们想看看上次同 origin 仓库通讯时master 的样子，就应该查看 origin/master 分支。如果你和同伴一起修复某个问题，但他们先推送了一个iss53 分支到远程仓库，虽然你可能也有一个本地的 iss53 分支，但指向服务器上最新更新的却应该是 origin/iss53 分支。</p>

<p>可能有点乱，我们不妨举例说明。假设你们团队有个地址为 git.ourcompany.com 的 Git 服务器。如果你从这里克隆，Git 会自动为你将此远程仓库命名为origin，并下载其中所有的数据，建立一个指向它的 master 分支的指针，在本地命名为 origin/master，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地master 分支，始于 origin 上 master 分支相同的位置，你可以就此开始工作</p>

<p><img src="/images/git-branch13.png" alt="alt text" /></p>

<p>一次 Git 克隆会建立你自己的本地分支 master 和远程分支 origin/master，它们都指向 origin/master 分支的最后一次提交。</p>

<p>如果你在本地 master 分支做了些改动，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，那么服务器上的master 分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 origin/master 指针仍然保持原位不会移动</p>

<p><img src="/images/git-branch14.png" alt="alt text" /></p>

<p>可以运行 git fetch origin 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置上</p>

<p><img src="/images/git-branch15.png" alt="alt text" /></p>

<p> git fetch 命令会更新 remote 索引</p>

<p> 为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器 git.team1.ourcompany.com。可以用第二章中提到的git remote add 命令把它加为当前项目的远程分支之一。我们把它命名为 teamone，以便代替原始的 Git 地址</p>

<p> <img src="/images/git-branch16.png" alt="alt text" /></p>

<p> 把另一个服务器加为远程仓库</p>

<p> 现在你可以用 git fetch teamone 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 origin 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为teamone/master 的分支，指向 teamone 服务器上 master 分支所在的提交对象31b8e</p>

<p> <img src="/images/git-branch17.png" alt="alt text" /></p>

<p>  你在本地有了一个指向 teamone 服务器上 master 分支的索引。</p>

<ul>
<li>推送本地分支</li>
</ul>


<p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你的本地分支不会被自动同步到你引入的远程服务器上，除非你明确执行推送操作。换句话说，对于无意分享的分支，你尽管保留为私人分支好了，而只推送那些协同工作要用到的特性分支。</p>

<p>如果你有个叫 serverfix 的分支需要和他人一起开发，可以运行 git push (远程仓库名) (分支名)</p>

<pre><code>$ git push origin serverfix Counting objects: 20, done. Compressing objects: 100% (14/14), done. Writing objects: 100% (15/15), 1.74 KiB, done. Total 15 (delta 5), reused 0 (delta 0) To git@github.com:schacon/simplegit.git * [new branch] serverfix -&gt; serverfix
</code></pre>

<p>其实有点像条捷径。Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。我们将在第九章进一步介绍refs/heads/ 部分的细节，不过一般使用的时候都可以省略它。也可以运行 git push origin serverfix:serferfix 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作awesomebranch，可以用 git push origin serverfix:awesomebranch 来推送数据。</p>

<p>接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支 origin/serverfix</p>

<pre><code>$ git fetch origin remote: Counting objects: 20, done. remote: Compressing objects: 100% (14/14), done. remote: Total 15 (delta 5), reused 0 (delta 0) Unpacking objects: 100% (15/15), done. From git@github.com:schacon/simplegit * [new branch] serverfix -&gt; origin/serverfix
</code></pre>

<p>值得注意的是，在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的serverfix 分支，有的只是一个你无法移动的 origin/serverfix 指针。</p>

<p>如果要把该内容合并到当前分支，可以运行 git merge origin/serverfix。如果想要一份自己的 serverfix 来开发，可以在远程分支的基础上分化出一个新的分支来：</p>

<p>$ git checkout -b serverfix origin/serverfix Branch serverfix set up to track remote branch refs/remotes/origin/serverfix. Switched to a new branch &ldquo;serverfix&rdquo;</p>

<p>这会切换到新建的 serverfix 本地分支，其内容同远程分支 origin/serverfix 一致，这样你就可以在里面继续开发了。</p>

<ul>
<li>跟踪远程分支</li>
</ul>


<p>从远程分支 checkout 出来的本地分支，称为<em>跟踪分支(tracking branch)</em>。跟踪分支是一种和远程分支有直接联系的本地分支。在跟踪分支里输入git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p>

<p>在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是git push 和 git pull 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如origin 上除了 master 之外的其它分支。刚才我们已经看到了这样的一个例子：git checkout -b [分支名] [远程名]/[分支名]。如果你有 1.6.2 以上版本的 Git，还可以用&ndash;track 选项简化</p>

<pre><code>$ git checkout --track origin/serverfix Branch serverfix set up to track remote branch refs/remotes/origin/serverfix. Switched to a new branch "serverfix"
</code></pre>

<p>要为本地分支设定不同于远程分支的名字，只需在前个版本的命令里换个名字：</p>

<pre><code>$ git checkout -b sf origin/serverfix Branch sf set up to track remote branch refs/remotes/origin/serverfix. Switched to a new branch "sf"
</code></pre>

<p>现在你的本地分支 sf 会自动向 origin/serverfix 推送和抓取数据了。</p>

<ul>
<li>删除远程分支</li>
</ul>


<p>如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的地方），可以用这个非常无厘头的语法来删除它：git push [远程名] :[分支名]。如果想在服务器上删除serverfix 分支，运行下面的命令</p>

<pre><code>$ git push origin :serverfix To git@github.com:schacon/simplegit.git - [deleted] serverfix
</code></pre>

<p><strong>咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：记住我们不久前见过的 git push [远程名] [本地分支]:[远程分支] 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”</strong></p>

<blockquote><pre><code>  分支的衍合
</code></pre></blockquote>

<p>把一个分支整合到另一个分支的办法有两种：merge 和 rebase（译注：rebase 的翻译暂定为“衍合”，大家知道就可以了。）。在本章我们会学习什么是衍合，如何使用衍合，为什么衍合操作如此富有魅力，以及我们应该在什么情况下使用衍合。</p>

<ul>
<li>基本的衍合操作</li>
</ul>


<p>请回顾之前有关合并的一节（见图），你会看到开发进程分叉到两个不同分支，又各自提交了更新。
<img src="/images/git-branch18.png" alt="alt text" /></p>

<p>之前介绍过，最容易的整合分支的方法是 merge 命令，它会把两个分支最新的快照（C3 和 C4）以及二者最新的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C5）
  <img src="/images/git-branch19.png" alt="alt text" /></p>

<p>  其实，还有另外一个选择：你可以把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍。在 Git 里，这种操作叫做<em>衍合（rebase）</em>。有了 rebase 命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍</p>

<p>  在上面这个例子中，运行</p>

<pre><code>    $ git checkout experiment $ git rebase master First, rewinding head to replay your work on top of it... Applying: added staged command
</code></pre>

<p> 它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 experiment）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支master）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 experiment 的提交历史，使它成为 master 分支的直接下游，</p>

<p>  <img src="/images/git-branch20.png" alt="alt text" /></p>

<p>  现在回到 master 分支，进行一次快进合并</p>

<p>  <img src="/images/git-branch21.png" alt="alt text" /></p>

<p>  现在的 C3’ 对应的快照，其实和普通的三方合并，即上个例子中的 C5 对应的快照内容一模一样了。虽然最后整合得到的结果没有任何区别，但衍合能产生一个更为整洁的提交历史。如果视察一个衍合过的分支的历史记录，看起来会更 清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。</p>

<p>一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁 — 比如某些项目你不是维护者，但想帮点忙的话，最好用衍合：先在自己的一个分支里进行开发，当准备向主项目提交补丁的时候，根据最新的origin/master 进行一次衍合操作然后再提交，这样维护者就不需要做任何整合工作（译注：实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。），只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。</p>

<p>请注意，合并结果中最后一次提交所指向的快照，无论是通过衍合，还是三方合并，都会得到相同的快照内容，只不过提交历史不同罢了。衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。</p>

<ul>
<li>有趣的衍合</li>
</ul>


<p>衍合也可以放到其他分支进行，并不一定非得根据分化之前的分支。下图 ，我们为了给服务器端代码添加一些功能而创建了特性分支 server，然后提交 C3 和 C4。然后又从 C3 的地方再增加一个client 分支来对客户端代码进行一些相应修改，所以提交了 C8 和 C9。最后，又回到 server 分支提交了 C10。</p>

<p>  <img src="/images/git-branch22.png" alt="alt text" /></p>

<p>  假设在接下来的一次软件发布中，我们决定先把客户端的修改并到主线中，而暂缓并入服务端软件的修改（因为还需要进一步测试）。这个时候，我们就可以把基于 server 分支而非 master 分支的改变（即 C8 和 C9），跳过 server 直接放到master 分支中重演一遍，但这需要用 git rebase 的 &ndash;onto 选项指定新的基底分支master：</p>

<pre><code> $ git rebase --onto master server client

 这好比在说：“取出 client 分支，找出 client 分支和 server 分支的共同祖先之后的变化，然后把它们在master 上重演一遍”。是不是有点复杂？不过它的结果如图 所示，非常酷（译注：虽然 client 里的 C8, C9 在 C3 之后，但这仅表明时间上的先后，而非在 C3 修改的基础上进一步改动，因为server 和 client 这两个分支对应的代码应该是两套文件，虽然这么说不是很严格，但应理解为在 C3 时间点之后，对另外的文件所做的 C8，C9 修改，放到主干重演。
</code></pre>

<p>  <img src="/images/git-branch23.png" alt="alt text" /></p>

<p>  现在可以快进 master 分支了：</p>

<pre><code> $ git checkout master $ git merge client
</code></pre>

<p> <img src="/images/git-branch24.png" alt="alt text" /></p>

<p> 现在我们决定把 server 分支的变化也包含进来。我们可以直接把 server 分支衍合到 master，而不用手工切换到 server 分支后再执行衍合操作 — git rebase [主分支] [特性分支] 命令会先取出特性分支server，然后在主分支 master 上重演</p>

<p> $ git rebase master server</p>

<p> 于是，server 的进度应用到 master 的基础上，如图</p>

<p> <img src="/images/git-branch25.png" alt="alt text" /></p>

<p>然后就可以快进主干分支 master 了：</p>

<pre><code>$ git checkout master $ git merge server
</code></pre>

<p>现在 client 和 server 分支的变化都已经集成到主干分支来了，可以删掉它们了。最终我们的提交历史会变成图</p>

<pre><code>$ git branch -d client $ git branch -d server
</code></pre>

<p> <img src="/images/git-branch26.png" alt="alt text" /></p>

<ul>
<li>衍合的风险</li>
</ul>


<p>呃，奇妙的衍合也并非完美无缺，要用它得遵守一条准则：</p>

<p><strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。</strong>
如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>

<p>在进行衍合的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用git rebase 抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。</p>

<p>下面我们用一个实际例子来说明为什么公开的衍合会带来问题。假设你从一个中央服务器克隆然后在它的基础上搞了一些开发，提交历史类似图</p>

<p> <img src="/images/git-branch27.png" alt="alt text" /></p>

<p>现在，某人在 C1 的基础上做了些改变，并合并他自己的分支得到结果 C6，推送到中央服务器。当你抓取并合并这些数据到你本地的开发分支中后，会得到合并结果 C7，历史提交会变成图</p>

<p> <img src="/images/git-branch28.png" alt="alt text" /></p>

<p> 接下来，那个推送 C6 上来的人决定用衍合取代之前的合并操作；继而又用 git push &ndash;force 覆盖了服务器上的历史，得到 C4’。而之后当你再从服务器上下载最新提交后，会得到：</p>

<p>  <img src="/images/git-branch29.png" alt="alt text" /></p>

<p>  下载更新后需要合并，但此时衍合产生的提交对象 C4’ 的 SHA-1 校验值和之前 C4 完全不同，所以 Git 会把它们当作新的提交对象处理，而实际上此刻你的提交历史 C7 中早已经包含了 C4 的修改内容，于是合并操作会把 C7 和 C4’ 合并为 C8</p>

<p>   <img src="/images/git-branch30.png" alt="alt text" /></p>

<p>  C8 这一步的合并是迟早会发生的，因为只有这样你才能和其他协作者提交的内容保持同步。而在 C8 之后，你的提交历史里就会同时包含 C4 和 C4’，两者有着不同的 SHA-1 校验值，如果用git log 查看历史，会看到两个提交拥有相同的作者日期与说明，令人费解。而更糟的是，当你把这样的历史推送到服务器后，会再次把这些衍合后的提交引入到中央服务 器，进一步困扰其他人（译注：这个例子中，出问题的责任方是那个发布了 C6 后又用衍合发布 C4’ 的人，其他人会因此反馈双重历史到共享主干，从而混淆大家的视听。）。</p>

<p>如果把衍合当成一种在推送之前清理提交历史的手段，而且仅仅衍合那些尚未公开的提交对象，就没问题。如果衍合那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。</p>

<h3>服务器上的git</h3>

<pre><code>省略
</code></pre>

<h3>git命令</h3>

<pre><code>Git 提供了一个叫做 git config 的工具（译注：实际是 git-config 命令，只不过可以通过 git 加一个名字来呼叫此命令。），专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：

/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用--system 选项，读写的就是这个文件。
~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用--global 选项，读写的就是这个文件。
当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以.git/config 里的配置会覆盖/etc/gitconfig 中的同名变量。
</code></pre>

<ul>
<li>git config &ndash;list  要检查已有的配置信息</li>
<li>git config &ndash;global user.name &ldquo;John Doe&rdquo;  配置用户名</li>
<li>git config &ndash;global user.email <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x6a;&#111;&#104;&#x6e;&#100;&#111;&#x65;&#64;&#x65;&#120;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#109;">&#106;&#111;&#x68;&#110;&#100;&#x6f;&#101;&#64;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;</a> 配置邮件</li>
<li>git config &ndash;global core.editor emacs   文本编辑器</li>
<li>git config &ndash;global merge.tool vimdiff  配置差异性分析工具（Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。）</li>
<li>git config user.name   查看用户名</li>
<li>git help  config  查看git config的文档</li>
<li>git &ndash;help 查看git使用文档</li>
<li>man git 查看git 文档</li>
<li><p>git help 查看git使用文档</p></li>
<li><p>git init  在工作目录中初始化新仓库（初始化后，在当前目录下会出现一个名为 .git 的目录）</p></li>
<li>git add git add &lt;文件或者文件夹> 可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）潜台词就是把目标文件快照放入暂存区域）</li>
<li>git commit -m &lsquo;initial project version&rsquo; 提交文件</li>
<li>git clone git://github.com/schacon/grit.git 克隆文件到当前文件夹</li>
<li>git clone git://github.com/schacon/grit.git mygrit  克隆文件到当前文件夹并将文件夹命名为 myfrit</li>
<li>git status 检查当前文件状态</li>
<li>cat .gitignore <em>.[oa] </em>~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件   （<strong>可以添加多个忽略文件匹配，之间用空格空开</strong>）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>文件 .gitignore 的格式规范如下：
</span><span class='line'>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。
</span><span class='line'>可以使用标准的 glob 模式匹配。 * 匹配模式最后跟反斜杠（/）说明要忽略的是目录。 *    要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。
</span><span class='line'>
</span><span class='line'>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如[0-9] 表示匹配所有 0 到 9 的数字）。</span></code></pre></td></tr></table></div></figure>


<ul>
<li>git diff  查看尚未暂存的文件更新了哪些部分</li>
<li><p>git diff &ndash;cached 已经暂存起来的文件和上次提交时的快照之间的差异</p>

<p>  例如 vim read
      git add read    ///这第一个新生产的问题提交到git 缓存区域了
      vim read 打开read 输入文字abc
      git add read   ///第二次保存快照
      vim  read  再次打开read  输入文字efg （现在文字问abcdef）</p>

<pre><code>  git diff  这时候输出的结果是
  diff --git a/README b/README
  index 40bae04..f74d0d3 100644
  --- a/README
  +++ b/README
  @@ -1 +1 @@
  -abc
  +abcdef

  比较的是未提交的文件与缓存区的文件比较（个人理解）

  git diff --cached 这时候输出的结果是
  diff --git a/README b/README
  new file mode 100644
  index 0000000..40bae04
  --- /dev/null
  +++ b/README
  @@ -0,0 +1 @@
  +abc

  比较的是缓存区最后两次的比较 （个人理解）
</code></pre></li>
<li><p>git commit 将暂存文件提交</p>

<pre><code> 可以看到，默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。退出编辑器时，Git 会丢掉注释行，将说明内容和本次更新提交到仓库。
</code></pre></li>
<li><p>git commit -m &ldquo;提交说明&rdquo; -m 参数后跟提交说明的方式，在一行命令中提交更新</p></li>
<li>git commit -a  自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</li>
<li>git rm 从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。</li>
<li>git rm -f 删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母），以防误删除文件后丢失修改的内容</li>
<li>git rm &ndash;cached readme.txt  另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆.a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 &ndash;cached 选项即可</li>
<li>git rm log/*.log  后面可以列出文件或者目录的名字，也可以使用 glob 模式</li>
<li><p>git mv file_from file_to 移动文件</p>

<pre><code> 其实，运行 git mv 就相当于运行了下面三条命令：
 $ mv README.txt README $ git rm README.txt $ git add README
</code></pre></li>
<li><pre><code>git log  查看提交历史
</code></pre></li>
<li><pre><code>git log -p -2   -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新
</code></pre></li>
<li><p>git commit &ndash;amend  有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 &ndash;amend 选项重新提交（修改提交信息）</p></li>
<li><p>git reset HEAD benchmarks.rb  取消已经暂存的文件</p></li>
<li><p>git checkout &ndash; benchmarks.rb  取消对文件的修改</p></li>
<li><p>git remote 查看当前的远程库</p></li>
<li>git remote -v 查看当前的远程库,显示对应的克隆地址</li>
</ul>


<blockquote><p>远程操作</p></blockquote>

<ul>
<li>git remote add [shortname] [url]  要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用（在我看来，就是和远程仓库建立一个连接，给命名了一个别名。网上说的迷迷糊糊的）</li>
<li><p>git fetch pb  到远程仓库中拉取所有你本地仓库中还没有的数据，运行完成后，你就可以在本地访问该远程仓库中的所有分支</p>

<pre><code>如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。所以，git fetch origin 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。

如果设置了某个分支用于跟踪某个远端仓库的分支（参见下节及第三章的内容），可以使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下git clone 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。
</code></pre></li>
<li><p>git push [remote-name] [branch-name] 将本地仓库中的数据推送到远程仓库</p>

<pre><code>  要把本地的 master 分支推送到origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：

  $ git push origin master

  只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那 你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。
</code></pre></li>
<li><pre><code>git remote show [remote-name] 查看某个远程仓库的详细信息
</code></pre></li>
<li><pre><code>git remote rename [pb] [paul] 对远程仓库的重命名 将pb重命名为paul
</code></pre></li>
<li><pre><code>git remote rm paul  删除paul远端仓库连接
</code></pre></li>
</ul>


<blockquote><p>2.6  打标签  (这个我用的不多暂时不弄这个了)</p></blockquote>

<ul>
<li>git tag  列出现有标签</li>
<li><p>git tag -a v1.4 -m &lsquo;my version 1.4&rsquo;  创建一个含附注类型的标签非常简单，用 -a 而 -m 选项则指定了对应的标签说明</p></li>
<li><p>git branch testing 新建一个 testing 分支</p></li>
<li>git checkout testing 切换testing分支</li>
<li>git checkout -b iss53  新建并切换到iss53分支</li>
<li>git merge hotfix 将hotfix分支merge到当前分支</li>
<li>$ git branch -d iss53  删除分支</li>
<li>git branch 查看分支</li>
<li>git branch -v 若要查看各个分支最后一个提交对象的信息</li>
<li>git branch &ndash;merged 筛选出已经与当前分支合并的分支</li>
<li>git branch &ndash;no-merged 筛选出已经与当前分支未合并的分支</li>
<li>git checkout &ndash;track  跟踪分支</li>
<li>git push [远程名] :[分支名]  删除分支
*git rebase master  将分支衍生到master上</li>
</ul>


<h4>参考链接：</h4>

<ul>
<li><a href="http://www.bootcss.com/p/git-guide/">git - 简易指南</a></li>
<li><a href="http://my.oschina.net/sunchp/blog/346076">git - 原理比较清晰</a></li>
</ul>


<h5>延伸连接</h5>

<ul>
<li><a href="http://www.open-open.com/lib/view/open1328069609436.html">git详解之一</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328069733264.html">git详解之二</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328069889514.html">Git详解之三 Git分支</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328069988843.html">Git详解之四 服务器上的Git</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328070090108.html">Git详解之五 分布式Git </a></li>
<li><a href="http://www.open-open.com/lib/view/open1328070367499.html">Git详解之六 Git工具 </a></li>
<li><a href="http://www.open-open.com/lib/view/open1328070404827.html">Git详解之七 自定义Git</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328070454218.html">Git详解之八 Git与其他系统 </a></li>
<li><a href="http://www.open-open.com/lib/view/open1328070620202.html">Git详解之九 Git内部原理</a></li>
</ul>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">温杰</span></span>

      




<time class='entry-date' datetime='2015-08-04T16:33:09+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:33 pm</span></time>
      


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/08/04/rakezai-octopresszhong-de-shi-yong-ming-ling-jie-shao/" title="Previous Post: rake在octopress中的使用命令介绍">&laquo; rake在octopress中的使用命令介绍</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/08/04/gitpages-plus-octopressda-jian-bo-ke-(zhuan-)/" title="Next Post: GitPages + Octopress搭建博客（转）">GitPages + Octopress搭建博客（转） &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/10/cgaffinetransform-dot-hlei-de-xue-xi-he-yuan-li-jiang-jie/">CGAffineTransform.h类的学习和原理讲解</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/04/ji-lu-unixming-ling-de-shi-yong/">记录unix命令的使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/04/gitpages-plus-octopressda-jian-bo-ke-(zhuan-)/">GitPages + Octopress搭建博客（转）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/04/gitde-xue-xi-shi-yong/">Git的学习使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/04/rakezai-octopresszhong-de-shi-yong-ming-ling-jie-shao/">Rake在octopress中的使用命令介绍</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - 温杰 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
